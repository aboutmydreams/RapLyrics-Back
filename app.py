import re
import os
import random

from flask import Flask, request, jsonify
from flask_cors import CORS

from fasttextgenrnn import textgenrnn

# We keep model as global variable so we don't have to reload it in case of warm invocations
# Model load which only happens during cold starts


app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": "*"}})

CUR_DIR = os.path.dirname(os.path.abspath(__file__))
WEIGHTS_DIR = os.path.join(CUR_DIR, "weights")

WEIGHTS_PATH = os.path.join(WEIGHTS_DIR, "RapLyrics_word2_01_weights.hdf5")
CONFIG_PATH = os.path.join(WEIGHTS_DIR, "RapLyrics_word2_01_config.json")
VOCAB_PATH = os.path.join(WEIGHTS_DIR, "RapLyrics_word2_01_vocab.json")

textgen = textgenrnn(config_path=CONFIG_PATH,
                     vocab_path=VOCAB_PATH,
                     weights_path=WEIGHTS_PATH)

textgen.generate()

regex1 = re.compile(r"\n+ ?")  # to avoid recompiling in hot start

"""Implements function used for lyrics generation in production"""


def output_cleaner(text):
    """
    Clean text generated by the multiple line generated by textgen.generate.
    Removes "^ ". Removes empty line. Clean other things TBD.
    :param text: text to clean
    :return: cleaned text
    """
    text = re.sub(regex1, "\n", text)
    text = text.replace("i ' m", "i'm")

    return text


def lyrics_generator(textgen, prefix, temperatures=[0.4, 0.5, 0.6], num_line=10, prefix_mode=2, prefix_proba=0.5):
    """
    Generate between 3 and 8 lines of strong lyrics. (number of lines is experimental)
    First line is  based on prefix. Other lines can be configured.
    :param textgen: the loaded model.
    :param prefix: begining text of first line
    :param temperatures: list of temperatures randomly used for generation.
    Put a single value in the list to make it constant
    :param num_line: number of lines to generate.
    The remaining lines will be less than this number at the end of the generation workflow.
    :param prefix_mode:
        0 use previous line + \n as prefix for next line
        1 don't use previous line as prefix. First line still uses the prefix given in argument.
        2 mode 0 with a probability of prefix_proba, else mode 1
    :param prefix_proba: proba of mode 0 to be used when in mode 2. In range 0.0-1.0
    :return: an AI generated savage rap hook
    """
    # Generate first line
    temperatures = random.choices(temperatures, k=num_line)
    line_list = textgen.generate(prefix=prefix, return_as_list=True, n=1, temperature=temperatures[0])

    # Manage empty prefix #FIXME to validate, maybe put elsewhere, or default to None?
    prefix = prefix if prefix else ""
    prefix_modes = random.choices([0, 1], weights=[prefix_proba, 1 - prefix_proba], k=num_line - 1)
    for i in range(num_line - 1):
        # Determine prefix mode if mode 2
        prefix_mode = prefix_modes[i]

        # Refine prefix for next line
        if prefix_mode == 0:
            prefix = line_list[-1] + "\n"
        elif prefix_mode == 1:
            prefix = None

        # Determine temperature
        temperature = temperatures[i + 1]

        # Generate new line
        new_line = textgen.generate(prefix=prefix, return_as_list=True, n=1, temperature=temperature)[0]
        new_line = new_line.replace(prefix[:-1],
                                    '') if prefix else new_line  # FIXME not sure if :-0 or :-1, put :-1 in testing function

        line_list.append(new_line)

    text = "\n".join(line_list)
    text = output_cleaner(text)

    return text


@app.route('/')
def hello():
    return "Cloud Runner Lyricist"


@app.route('/predict', methods=["POST"])
def handler():
    """ Responds to an HTTP request using data from the request body parsed
        according to the "content-type" header.
        Args:
            request (flask.Request): The request object.
            <http://flask.pocoo.org/docs/1.0/api/#flask.Request>
        Returns:
            The response text, or any set of values that can be turned into a
            Response object using `make_response`
            <http://flask.pocoo.org/docs/1.0/api/#flask.Flask.make_response>.
        """

    # Set CORS headers for the preflight request
    if request.method == 'OPTIONS':
        # Allows GET requests from any origin with the Content-Type
        # header and caches preflight response for an 3600s
        headers = {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'POST',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Access-Control-Max-Age': '3600'
        }
        return '', 204, headers

    content_type = request.headers['content-type']
    if content_type == 'application/json':
        request_json = request.get_json(silent=True)
        if request_json and 'input' in request_json:
            input_data = request_json['input']
        else:
            raise ValueError("JSON is invalid, or missing a 'input' property")
    elif content_type == 'application/octet-stream':
        input_data = request.data
    elif content_type == 'text/plain':
        input_data = request.data
    elif content_type == 'application/x-www-form-urlencoded':
        input_data = request.form.get('input')
    else:
        raise ValueError("Unknown content type: {}".format(content_type))

    punc = ["(", ")", "[", "]"]  # FIXME: add other cleaning if necessary, check if not redundant with library cleaning
    prefix = "".join(c.lower() for c in input_data if c not in punc)

    # 3 call model predict function
    prediction = lyrics_generator(textgen, prefix,
                                  temperatures=[0.5, 0.6, 0.7], num_line=5,
                                  prefix_mode=2, prefix_proba=0.5)

    return jsonify({"output": prediction})


if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))
